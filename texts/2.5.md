# Размер задач. Задача о ханойской башне

## Вступление

Мы продолжаем знакомство с концепцией размера задачи, и переходим от бинарного поиска из вступительной лекции CS50 к задаче о Ханойской Башне, изложенной в "Конкретной Математике" Кнута.

## Задача о ханойской башне

![скрин "Конкретной Математики" о Ханойской Башне](./img/2.5/hanoi-intro.png)


### Описание задачи

Есть три стержня. На первый нанизана упорядоченная пирамидка из N дисков, так что внизу — самый крупный, вверху — самый маленький. Единственная допустимая операция — перекладывание диска с одного стержня на другой. Больший диск положить класть сверху на меньший запрещается. Цель задачи — перенести пирамидку целиком с одного диска на другой за минимальное количество операций (перекладывания диска).

На примере этой задачи хотелось бы не только продолжить рассмотрение концепций размера задачи, сложности алгоритма и рекурсии/реккурентности, но и проиллюстрировать процесс выработки алгоритма и структуры данных, необходимых для формального (то есть доступного для кодирования) решения задачи.

### Первые попытки решения задачи

Практически для всех задач, параметризированных по их размеру (в нашем случае дисков может быть любое натуральное N) полезно начать с попыток определения тривиальных решений для малых N. В нашем случае начнём с ответа на простой вопрос: сколько и каких операций необходимо для перекладывания пирамидки из одного единственного диска с первого стержня на третий?

#### Решение задачи для случая с одним единственным диском (N = 1)

 Ответ, конечно, очевиден: переложить нужно этот один единственный диск. Как мы его запишем? Давайте сразу начнём использовать английский в наших записях. `Move` значит "подвинуть, переместить" — так и назовём нашу первую функцию. Перемещаем мы диск со стержня на стержень — стало быть, у функции должно быть два параметра.

```javascript
move(1, 3) // может быть, стоит записывать операцию переноса диска с первого стержня на третий так?
move(departure_rod, destination_rod) // а обобщённо, со стержня departure_rod на стержень destination_rod — так?
// выглядит неплохо
// кстати, "departure" по-английски — "отправление", "destination" — "назначение",
// эти слова вы могли видеть в аэропорту или на вокзале
// а "rod", разумеется, переводится как "стержень"
```

Помимо атомарной операции перемещения, у нас ещё есть собственно решение задачи целиком. Назовём эту функцию `solve_hanoi` — "решить (задачу) ханой(-ской башни)". Какие у неё могут быть аргументы? Как минимум, высота башни — N. А каково само решение? Пока не ясно в общем случае, но уже понятно что делать для случая с единственным диском: просто переложить его, не мудрствуя лукаво.

```javascript
function solve_hanoi(N) {
    if (N == 1) {
        move(1, 3);
        // заметим, что функция `move` у нас до сих пор толком не определена
        // мы пока не столько пишем код, сколько размышляем и пытаемся нащупать решение
    }
}
```

Минуточку, а почему это мы перемещаем пусть даже единственный диск именно *с первого стержня на третий*? Ведь задача может быть сформулирована и для пирамидки, изначально расположенной, например, на втором стержне, или для переноса её не на третий, а на второй стержень! Выходит, надо добавить параметров: объявление `solve_hanoi(N)` превратится в `solve_hanoi(N, departure_rod, destination_rod)`, а определение будет следующим:

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        move(departure_rod, destination_rod);
        // изменилось только лишь то, что мы заменили константы 1 и 3
        // на параметры departure_rod и destination_rod
    }
}
```

Здорово, конечно, но и функцию move надо бы определить. Как будем хранить данные? Нам нужно знать а) какие диски лежат на каком стержне и б) в каком порядке. А самих стержней — три. Вполне подойдёт массив из трёх элементов, как-то описывающих состояние стержня (количество и порядок дисков на нём). Количество и порядок дисков тоже вполне неплохо представить в виде массива. Для исходного условия задачи с одним единственным диском получим такую конструкцию: `[[1], [], []]`, а решением её должно будет стать `[[], [], [1]]` — единственный диск перенесён с первого стержня на второй. Структура данных диктует нам алгоритм: функция `move` должна переводить одно состояние в другое. Само состояние давайте пока считать глобальным. Немного подумав, можно записать полученный подход таким псевдокодом:

```javascript
hanoi_1 = [ // начальное состояние для задачи с одним единственным диском
    [1], // на первом стержне лежит наш диск
    [], // второй стержень пуст
    [] // третий — тоже
]

function move(departure_rod, destination_rod) {
    // 1. снять диск со стержня departure_rod
    // (то есть удалить его из массива hanoi_1[departure_rod])
    // 2. положить снятый диск на destination_rod
    // (то есть добавить его к массиву hanoi_1[destination_rod])
}
```

Возникает вопрос как именно снимать и класть диски — то есть, как именно добавлять или удалять элементы из массива в используемом языке. Это вопрос реализации, и в используемом нами языке JavaScript у массивов есть свои методы. В нашем простейшем случае мы можем обойтись даже тупой заменой массива, представляющего стержень:

```javascript

function move(departure_rod, destination_rod) {
    hanoi_i[departure_rod] = []
    hanoi_i[destination_rod] = [1]
    // тупо донельзя, но для задачи размера 1 — сойдёт и так
}
``` 

Выглядит откровенно хреново? Так и есть, отрицать не будем. Но мы ведь занимаемся поиском решения, а не его оптимизацией — до оптимизации ещё дойдём. Мы даже можем запустить в консоли этот код — и он сработает: `solve_hanoi(1, 1, 3)`. Но давайте перейдём к случаю с двумя дисками.

#### Решение задачи для случая с двумя дисками (N = 2)

Воспользуемся полученным на предыдущем шаге форматом данных, и опишем исходное условие и желаемый результат:

```javascript
// исходное состояние для N = 2
hanoi_2 = [[1, 2], [], []]
// желаемый результат
hanoi_2_desired_result = [[], [], [1, 2]]
```

На первом стержне у нас уже два диска, в первом массиве — два объекта. Логично их пронумеровать: первый диск и второй, мы так и поступили. Нужно учесть порядок дисков: давайте считать, что первой цифре в массиве соответствует самый верхний диск, а последней — самый нижний. Можем ли мы поступить наоборот? Да запросто, лишь бы этот порядок соблюдался для всех стержней, и учитывался при перемещений (брать можно всегда только самый верхний диск).

Вспомним, какие у нас есть ограничения для операции перекладывания диска? Во-первых, мы всегда обязаны брать самый верхний диск. Значит, если верхний диск мы договорились представлять первой цифрой массива, массив "отправления" покидать должна всегда именно она. Во-вторых, запрещено класть больший диск сверху на больший — значит, перед перекладыванием нам стоит проверить, не находится ли наверху целевого стержня диск меньше, чем на исходном. Состояние, которое запрещено правилами (постановкой задачи) будем называть запрещённым состоянием. Запрещёнными состояниями для задачи размера N = 2 являются [[2,1], [], []] и два аналогичных на других стержнях: [[], [2, 1], []], [[], [], [2,1]] — все в силу того, что болший (второй) диск лежит сверху на меньшем.

Давайте изменим функцию `move` так, чтобы она удовлетворяла нашим правилам. Сначала без проверки, само действие перекладывания:

```javascript
function move(departure_rod, destination_rod) {
    top_disk = hanoi_2[departure_rod].shift() // снимаем диск сверху со стержня departure_rod
    hanoi_2[destination_rod].unshift(top_disk) // кладём его сверху на стержень destination_rod
}
```

Мы использовали встроенные методы работы с массивами JavaScript `shift` и `unshift`. Они делают как раз то, что нам нужно: первая забирает элемент из начала массива, вторая — напротив, добавляет элемент в начало массива. В рамках используемой метафоры так и получается: сняли диск, положили диск. Можно, кстати, обойтись и без промежуточной переменной `top_disk` ("верхний диск"), и записать сразу такое выражение: `hanoi_2[destination_rod].unshift(hanoi_2[departure_rod].shift())` — но мы так выпендриваться пока не будем, читается оно ощутимо хуже. Преждевременная оптимизация — корень многих зол, нам пока важнее понимать, что мы делаем — а не делать это очень быстро и эффективно.

Добавим проверку? А давайте вынесем её в отдельную функцию, она ведь имеет самостоятельным смысл. Назовём, скажем `is_move_possible` — "возможно ли перемещение"? Заодно и игра слов красивая проявится — "move"-то по-английски ещё и "ход" (в игре) обозначает. Ваш ход, господин программист.
Давайте подумаем. Мы точно можем переложить любой диск на пустой стержень, и мы точно можем переложить диск на стержень, верхний диск на котором больше перекладываемого. В остальных случаях мы, похоже, будем нарушать правила. Ещё момент: с уже пустого стержня мы ничего никуда переложить не можем — ну нечего же перекладывать =) Закодируем!

```javascript
function is_move_possible(departure_rod, destination_rod) {
    if (departure_rod.length == 0) {
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    return destination_rod[0] > departure_rod[0];
}
```

### Реккурентная формула

TODO

#### Получение

TODO

#### Код

TODO

### Замкнутая форма

TODO

#### Получение

TODO

#### Код

TODO

### Конечный автомат

TODO
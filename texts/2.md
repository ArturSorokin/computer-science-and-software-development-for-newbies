# День 2: Размер задач. Двоичный поиск. Ханойская Башня

Всем привет! День третий — полёт нормальный.

## Вступление

В первый день мы посмотрели вводную лекцию CS50. Помимо моря завлекушечек и внезапных технознаменитостей, в ней затрагивалось две важных темы: кодирование данных и размер задач.

С кодированием данных мы рассмотрели позиционные системы счисления, и в частности двоичную систему счисления. Повторяться не будем, см. пост ниже.

## Двоичный поиск

### Описание задачи

А вот про размер задач сейчас поговорим. В лекции была рассмотрена задача поиска телефона по фамилии и имени человека в телефонном справочнике. Справочник — большая книжка, содержащая пары “фамилия имя — телефон”, отсортированные алфавитно по фамилиям. Справочник может быть большим или маленьким, и отличие будет в количестве пар “фамилия имя — телефон”. Может быть справочник на 100 телефонов, на 1000, на 2500, на 50000, на миллион — можно сказать, что телефонов в справочнике N штук. Это самое N и называют размером задачи. А сама задача формулируется так: “найти конкретный телефон по имеющимся имени и фамилии в справочнике на N пар “фамилия имя — телефон”, отсортированном алфавитно по фамилиям (и, в рамках одной и той же фамилии, по именам)”. Вот так вот — чуть громоздко, зато точно.

### Ключевая идея решения

Лектор курса CS50 задачу решил эффектно — буквально, разорвал сложность на части. Воспользовавшись тем, что телефонный справочник упорядочен, он обнаружил: искомая фамилия всегда находится либо в первой его половине, либо во второй, это можно сказать с уверенностью. Более того, можно с уверенностью сказать в какой именно: если искомая фамилия по алфавиту находится позднее, чем фамилия ровно посередине справочника — то во второй, иначе — в первой. Можно заметить, что мы сейчас сформулировали типичную операцию принятия решения (“если — то — иначе”, “if — then — else”) — это действительно так, в конструкциях любого императивного языка программирования мы бы её так и записали. А повторение действия для уменьшенной вдвое задачи — это вполне себе типичный цикл (или столь же типичная рекурсия, о чём ниже).

### Уменьшение сложности

Каждый раз, когда мы выбираем одну из половин справочника, мы уменьшаем сложность рассматриваемой задачи вдвое. Был справочник с N телефонов — а осталась его половина с N/2 телефонов. Остаётся только повторить процесс до тех пор, пока мы не найдём искомую запись. Конечно, вручную мы обычно ищем немного по-другому, комбинируя этот подход с последовательным просмотром, но для программирования двоичный поиск (а именно так называется этот подход) просто незаменим — и да, он ух как оптимален. Раз на каждом шаге мы уменьшаем сложность задачи вдвое, то будет верно и обратное: чтобы решить задачу вдвое большей сложности нам понадобиться добавить всего лишь одно действие! Правда-правда: поиск в справочнике на миллиард телефонов и поиск в справочнике на два миллиарда будут отличаться всего лишь единственным его открытием на середине!

### Псевдокод

#### Версия первая: код на русском языке

Можем записать небольшой псевдокод для нашей задачи, на русском языке:

Входные данные (что мы имеем изначально):
* список пар “фамилия, имя — телефон”, отсортированный по алфавиту (сначала фамилии, если фамилии совпадают — имена) — состоит из N пар. Говорят “длина списка равна N”, или, более общо, “размер задачи равен N”
* фамилия и имя искомого человека

Выходные данные (что мы хотим узнать):
* телефон искомого человека
* место в списке, где находится запись об искомом человеке и его телефоне

Метод решения:
1. Мы начинаем поиск, рассматривая список целиком — любой из N элементов может оказаться нашим искомым
2. Открываем справочник ровно посередине и сравниваем среднюю запись с искомой.
3. Если средняя фамилия справочника совпадает с искомой — ура, мы всё нашли. Закончить работу, вернуть обнаруженную пару.
4. Если средняя фамилия справочника по алфавиту идёт позднее искомой — вторую часть справочника мы отбрасываем (упрощаем задачу себе вдвое тем самым), а в первой повторяем поиск начиная с пункта (2) нашего алгоритма
5. Если же средняя фамилия справочника по алфавиту идёт раньше искомой, то отбрасываем уже первую часть справочника, а поиск с пункта (2) повторяем для второй.

Всё, алгоритм записан. Многословно, зато вполне понятно любому русскоговорящему человеку. Но давайте пойдём дальше и его формализуем: слов станет поменьше, математической записи — побольше, и это приблизит нас к программной реализации.

#### Версия вторая: формализуем запись

Входные данные:
* phonebook — массив пар (person, phone), где person — строка вида “Surname Name”, phone —  строка вида “555-55-55”. Порядок пар задан алфавитным порядком строк person. Каждая пара имеет свой номер, по которому можно к ней обратиться.
* lookup_person — строка, содержащая имя и фамилию искомой персоны

Пример входных данных:

```javascript
phonebook = [
  ["Абалаев Иван", "111-11-11"],        // элемент списка №0 
  ["Баранов Сергей", "222-11-11"],      // элемент списка №1
  ["Волкова Ольга", "333-11-11"],       // элемент списка №2
  ["Громов Пётр", "444-11-11"],         // элемент списка №3
  ["Добрая Анна", "555-11-11"],         // элемент списка №4
  ["Ежова Елизавета", "666-11-11"]      // элемент списка №5
]
```

Квадратными скобками мы группируем данные: строки в парах, и пары в список.
Кавычки нам нужны для обозначения строк.
Элементы в массиве традиционно нумеруются с нуля (для этого есть причины, но мы их пока касаться не будем — просто запомним).
Двойной косой чертой `//` мы помечаем комментарии "для себя" — они в принципе не нужны, но нам так понятнее будет

Можно обратиться к элементу в списке по его номеру:
* `phonebook[0]` даст нам в результате `["Абалаев Иван", "111-11-11"]`
* `phonebook[3]` — `["Громов Пётр", "444-11-11"]`
* `phonebook[-1]` или `phonebook[6]` — это ошибочные обращения, у нас нет элементов по таким номерам

Пускай мы ищем конкретную девушку (романтика, ну?):

```javascript
lookup_person = "Добрая Анна"
```

В рамках каждой пары "человек - телефон" мы можем обратиться как к строке с фамилией и именем, так и к строке с телефоном: опять же, по номеру (говорят *по индексу*):

* `["Громов Пётр", "444-11-11"][0]` даст нам `"Громов Пётр"`
* `["Громов Пётр", "444-11-11"][1]` — `"444-11-11"`
* `["Громов Пётр", "444-11-11"][-1]` или `["Громов Пётр", "444-11-11"][2]` — ошибочные обращения, у этой пары есть только индексы 0 и 1.

Можно совместить индексирование телефонной книги и индексирование телефонной пары:

* `phonebook[0][0]` — получится `"Абалаев Иван"`
* `phonebook[0][1]` - получится `"111-11-11"`
* `phonebook[10][1]` - ошибка обращения по индексу к телефонной книге
* `phonebook[1][5]` - ошибка обращения по индексу к паре (мы получим `["Баранов Сергей", "222-11-11"][5]`, и упадём на попытке взять индекс 5 от пары, где существуют только индексы 0 и 1)

Я специально заостряю внимание на возможных ошибках — чтобы вы не пугались их и могли их понять, когда столкнётесь с ними в реальности.

Теперь нам нужна операция сравнения строк. Будем использовать привычные математические символы "равно", "больше" и "меньше", но с одной поправкой: чтобы отличать проверку на равенство от присваивания, проверку на равенство будем записывать двумя символами: `"=="`, а не `=`.

Операции проверки возвращают нам либо `true` (истину), либо `false` (ложь). Например:

* `"Громов Пётр" == "Громов Пётр"` вернёт `true` — строки совпадают, проверяемое условие выполняется
* `"Громов Пётр" == "Добрая Ольга"` вернёт `false` — строки различаются, проверяемое условие не выполняется
* `"Громов Пётр" < "Добрая Ольга"` вернёт `true` — по алфавиту "Громов" идёт до "Добрая", условие выполняется
* `"Абалаев Иван" > "Добрая Ольга"` вернёт `false` — по алфавиту "Абалаев" идёт тоже до "Добрая", так что условие не выполняется

Можно совместить индексирование, проверки и нашу входную переменную `lookup_person` (которая, как вы помните, имеет в нашем примере значение `"Добрая Анна"`):

* `phonebook[0][0] == "Абалаев Иван"` — чистая правда, то есть `true`
* `phonebook[1][0] == "Абалаев Иван"` — а вот это уже ложь, упрощается до `"Баранов Сергей" == "Абалаев Иван"` — очевидно же что `false`
* `phonebook[0][1] == "Абалаев Иван"` — тоже `false`, просто потому что мы слева от проверки на равенство получим телефон, а не фамилию.
* `phonebook[0][0] < phonebook[1][0]` — `true`, по условию задачи массив по фамилиям упорядочен
* `phonebook[3][0] < phonebook[1][0]` — `false`, по условию задачи массив по фамилиям упорядочен
* `phonebook[0][0] < lookup_person` — `true`, упрощается до `"Абалаев Иван" < "Добрая Анна"`, а "Абалаев" по алфавиту идёт раньше чем "Добрая"

Ну что ж, теперь можно и псевдокод записать:

```javascript

function binary_search (phonebook, lookup_person) {
    middle_pair = получить_среднюю_запись(phonebook)
    middle_person = middle_pair[0]
    if (middle_person == lookup_person) {
        // ура, мы всё нашли
        middle_phone = middle_pair[1]
        return middle_phone;
        // возвращаем телефон
    }
    if (middle_person < lookup_person) {
        // искомая персона по алфавиту расположена после средней в рассматриваемой части телефонной книги
        // значит искать надо во второй половине рассматриваемой части телефонной книги
        half_of_the_task = получить_вторую_половину(phonebook)
        return binary_search(half_of_the_task, lookup_person)
    }
    if (middle_person > lookup_person) {
        // искомая персона по алфавиту расположена до средней в рассматриваемой части телефонной книги
        // значит искать надо во второй половине рассматриваемой части телефонной книги
        half_of_the_task = получить_первую_половину(phonebook)
        return binary_search(half_of_the_task, lookup_person)
    }
}

```

Круглые скобки мы используем для выделения входных параметров (см. `function binary_search (phonebook, lookup_person)`) и операций проверок (см.  `if (middle_person == lookup_person)`). Фигурные скобки группируют действия в блоки последовательностей.

У нас остались не вполне определёнными действия:

* получить_среднюю_запись(phonebook)
* получить_первую_половину(phonebook)
* получить_вторую_половину(phonebook)

Давайте разберёмся с ними. Все три получают на вход телефонную книгу. Первое должно нам вернуть среднюю пару ["Фамилия Имя", "телефон"], второе и третье — половинку телефонной книги. Мы знаем, что телефонная книга индексируется, и у каждой пары есть номер (`phonebook[0]`, `phonebook[1]` и т.д.). Мы знаем, что длина телефонной книги ограничена и известна. Давайте обозначим её как phonebook.length — свойство "длина" объекта "телефонная книга". Мы знаем, что нумерация индексов начинается с нуля.

Давайте посмотрим на данные в нашем примере ещё раз:

```javascript
phonebook = [
  ["Абалаев Иван", "111-11-11"],        // элемент списка №0 
  ["Баранов Сергей", "222-11-11"],      // элемент списка №1
  ["Волкова Ольга", "333-11-11"],       // элемент списка №2
  ["Громов Пётр", "444-11-11"],         // элемент списка №3
  ["Добрая Анна", "555-11-11"],         // элемент списка №4
  ["Ежова Елизавета", "666-11-11"]      // элемент списка №5
]
```

Пар в телефонной книге шесть. Значит, `phonebook.length == 6`, а индекс последнего элемента равен `phonebook.length - 1` то есть `5`: `phonebook.length - 1 == 5`.

Какую из пар принять за среднюю? С чётным числом записей это решение будет произвольным: можно взять элемент №2, можно — №3. Хочется уметь получать индекс среднего элемента простым арифметическим действием, как например делением без остатка. `6/2 == 3` — выглядит неплохо, давайте попробуем. Общее правило получается такое: индекс среднего элемента равен "длина массива пополам": `phonebook.length / 2`. Тогда получение средней записи можно записать так (заодно переименуем её по-английски):

```javascript

function get_middle_record(phonebook) {
    middle_index = phonebook.length / 2
    return phonebook[middle_index]
}
```

Несложно, правда?

Давайте теперь возьмёмся за получение половинок. Как получить средний индекс мы уже знаем, очевидно что первой половиной будет "от нулевого до среднего", второй — "от среднего до последнего". Тут пришла пора открыть читателю страшный секрет: наш псевдокод на самом деле не такой уж и псевдо — это вполне себе нормальный язык программирования JavaScript. А в JavaScript для этих целей есть встроенная функция `slice` (англ. "срезать"), и работает она как раз так, как нам хочется:

![](./slicing.png)

С учётом этого, можем записать наши недостающие функции таким образом:

```javascript

function get_first_half(phonebook) {
    middle_index = phonebook.length / 2
    return phonebook.slice(0, middle_index)
}

function get_second_half(phonebook) {
    middle_index = phonebook.length / 2
    return phonebook.slice(middle_index, phonebook.length)
}
```
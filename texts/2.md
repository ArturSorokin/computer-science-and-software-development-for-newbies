# День 2: Размер задач. Двоичный поиск. Ханойская Башня

Всем привет! День третий — полёт нормальный.

## Вступление

В первый день мы посмотрели вводную лекцию CS50. Помимо моря завлекушечек и внезапных технознаменитостей, в ней затрагивалось две важных темы: кодирование данных и размер задач.

С кодированием данных мы рассмотрели позиционные системы счисления, и в частности двоичную систему счисления. Повторяться не будем, см. пост ниже.

## Двоичный поиск

### Описание задачи

А вот про размер задач сейчас поговорим. В лекции была рассмотрена задача поиска телефона по фамилии и имени человека в телефонном справочнике. Справочник — большая книжка, содержащая пары “фамилия имя — телефон”, отсортированные алфавитно по фамилиям. Справочник может быть большим или маленьким, и отличие будет в количестве пар “фамилия имя — телефон”. Может быть справочник на 100 телефонов, на 1000, на 2500, на 50000, на миллион — можно сказать, что телефонов в справочнике N штук. Это самое N и называют размером задачи. А сама задача формулируется так: “найти конкретный телефон по имеющимся имени и фамилии в справочнике на N пар “фамилия имя — телефон”, отсортированном алфавитно по фамилиям (и, в рамках одной и той же фамилии, по именам)”. Вот так вот — чуть громоздко, зато точно.

### Ключевая идея решения

Лектор курса CS50 задачу решил эффектно — буквально, разорвал сложность на части. Воспользовавшись тем, что телефонный справочник упорядочен, он обнаружил: искомая фамилия всегда находится либо в первой его половине, либо во второй, это можно сказать с уверенностью. Более того, можно с уверенностью сказать в какой именно: если искомая фамилия по алфавиту находится позднее, чем фамилия ровно посередине справочника — то во второй, иначе — в первой. Можно заметить, что мы сейчас сформулировали типичную операцию принятия решения (“если — то — иначе”, “if — then — else”) — это действительно так, в конструкциях любого императивного языка программирования мы бы её так и записали. А повторение действия для уменьшенной вдвое задачи — это вполне себе типичный цикл (или столь же типичная рекурсия, о чём ниже).

### Уменьшение сложности

Каждый раз, когда мы выбираем одну из половин справочника, мы уменьшаем сложность рассматриваемой задачи вдвое. Был справочник с N телефонов — а осталась его половина с N/2 телефонов. Остаётся только повторить процесс до тех пор, пока мы не найдём искомую запись. Конечно, вручную мы обычно ищем немного по-другому, комбинируя этот подход с последовательным просмотром, но для программирования двоичный поиск (а именно так называется этот подход) просто незаменим — и да, он ух как оптимален. Раз на каждом шаге мы уменьшаем сложность задачи вдвое, то будет верно и обратное: чтобы решить задачу вдвое большей сложности нам понадобиться добавить всего лишь одно действие! Правда-правда: поиск в справочнике на миллиард телефонов и поиск в справочнике на два миллиарда будут отличаться всего лишь единственным его открытием на середине!

### Псевдокод

#### Версия первая: код на русском языке

Можем записать небольшой псевдокод для нашей задачи, на русском языке:

Входные данные (что мы имеем изначально):
* список пар “фамилия, имя — телефон”, отсортированный по алфавиту (сначала фамилии, если фамилии совпадают — имена) — состоит из N пар. Говорят “длина списка равна N”, или, более общо, “размер задачи равен N”
* фамилия и имя искомого человека

Выходные данные (что мы хотим узнать):
* телефон искомого человека
* место в списке, где находится запись об искомом человеке и его телефоне

Метод решения:
1. Мы начинаем поиск, рассматривая список целиком — любой из N элементов может оказаться нашим искомым
2. Открываем справочник ровно посередине и сравниваем среднюю запись с искомой.
3. Если средняя фамилия справочника совпадает с искомой — ура, мы всё нашли. Закончить работу, вернуть обнаруженную пару.
4. Если средняя фамилия справочника по алфавиту идёт позднее искомой — вторую часть справочника мы отбрасываем (упрощаем задачу себе вдвое тем самым), а в первой повторяем поиск начиная с пункта (2) нашего алгоритма
5. Если же средняя фамилия справочника по алфавиту идёт раньше искомой, то отбрасываем уже первую часть справочника, а поиск с пункта (2) повторяем для второй.

Всё, алгоритм записан. Многословно, зато вполне понятно любому русскоговорящему человеку. Но давайте пойдём дальше и его формализуем: слов станет поменьше, математической записи — побольше, и это приблизит нас к программной реализации.

#### Версия вторая: формализуем запись

Входные данные:
* phonebook — массив пар (person, phone), где person — строка вида “Surname Name”, phone —  строка вида “555-55-55”. Порядок пар задан алфавитным порядком строк person. Каждая пара имеет свой номер, по которому можно к ней обратиться.
* lookup_person — строка, содержащая имя и фамилию искомой персоны

Пример входных данных:

```javascript
phonebook = [
  ["Абалаев Иван", "111-11-11"],        // элемент списка №0 
  ["Баранов Сергей", "222-11-11"],      // элемент списка №1
  ["Волкова Ольга", "333-11-11"],       // элемент списка №2
  ["Громов Пётр", "444-11-11"],         // элемент списка №3
  ["Добрая Анна", "555-11-11"],         // элемент списка №4
  ["Ежова Елизавета", "666-11-11"]      // элемент списка №5
]
```

Квадратными скобками мы группируем данные: строки в парах, и пары в список. Кавычки нам нужны для обозначения строк. Элементы в массиве традиционно нумеруются с нуля (для этого есть причины, но мы их пока касаться не будем — просто запомним). Можно обратиться к элементу в списке по его номеру:
* phonebook[0] == ["Абалаев Иван", "111-11-11"]
* phonebook[3] == ["Громов Пётр", "444-11-11"]
* phonebook[-1] или phonebook[6] — ошибочные обращения, у нас нет элементов по таким номерам

